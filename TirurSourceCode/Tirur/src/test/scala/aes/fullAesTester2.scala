package aes

import chisel3._
import chisel3.iotesters._
import chisel3.iotesters.{Driver,ChiselFlatSpec,PeekPokeTester}

class fullAesTestes2(a:aes) extends PeekPokeTester(a)
{
  val pt ="h00000000000000000000000000000000"
  val key= "h00000000000000000000000000000000"
  val ept= "h66e94bd4ef8a2c3b884cfa59ca342b2e"
  
  //encryption test
  poke(a.io.key,key.U)
  poke(a.io.en,true.B)
  poke(a.io.iData,pt.U)
  poke(a.io.ed,true.B)
  step(11)
  expect(a.io.done,true.B)
  expect(a.io.result,ept.U)
  
  val pt0  = "h00000000000000000000000000000001"
  val ept0 = "h58e2fccefa7e3061367f1d57a4e7455a"
  
  poke(a.io.key,key.U)
  poke(a.io.en,true.B)
  poke(a.io.iData,pt0.U)
  poke(a.io.ed,true.B)
  step(11)
  expect(a.io.done,true.B)
  expect(a.io.result,ept0.U)
  
  val pt1="h00000000000000000000000000000002"
  val ept1="h0388dace60b6a392f328c2b971b2fe78"
  poke(a.io.key,key.U)
  poke(a.io.en,true.B)
  poke(a.io.iData,pt1.U)
  poke(a.io.ed,true.B)
  step(11)
  expect(a.io.done,true.B)
  expect(a.io.result,ept1.U)
  
  
  
//  poke(a.io.key,key.U)
//  poke(a.io.en,true.B)
//  poke(a.io.iData,pt.U)
//  poke(a.io.ed,true.B)
//  step(11)
//  expect(a.io.done,true.B)
//  expect(a.io.result,ept.U)
//  
//  
//  //decryption test, round keys already generated by the encription process
//  poke(a.io.key,key.U)
//  poke(a.io.en,true.B)
//  poke(a.io.iData,ept.U)
//  poke(a.io.ed,false.B)
//  step(11)
//  expect(a.io.done,true.B)
//  expect(a.io.result,pt.U)
//  
//  
//  //key change logic test
//  val nres = "h2C936BA3DDFFDDF452D4E407570A5388"
//  val nk= "h5468617470206d79204b756e67204675"
//  
//  poke(a.io.key,nk.U)
//  poke(a.io.en,true.B)
//  poke(a.io.iData,ept.U)
//  poke(a.io.ed,false.B)
//  step(24)
//  expect(a.io.done,true.B)
//  expect(a.io.result,nres.U)
//  
  
  
}

class fullAesTester2 extends ChiselFlatSpec{
  behavior of "Aes"
  backends foreach{ backend =>
    it should s"encript the input data" in {
      Driver(()=>new aes,backend)(a=> new fullAesTestes2(a)) should be (true)
    } 
    
  }
}
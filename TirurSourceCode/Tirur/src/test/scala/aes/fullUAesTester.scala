package aes

import chisel3._
import chisel3.iotesters._
import chisel3.iotesters.{Driver,ChiselFlatSpec,PeekPokeTester}

class fullUAesTestes(a:uaes) extends PeekPokeTester(a)
{
  step(2)
  val pt ="h54776f204f6e65204e696e652054776f"
  val key= "h5468617473206d79204b756e67204675"
  val ept= "h29C3505F571420F6402299B31A02D73A"
  
  //encryption test
  poke(a.io.key,key.U)
  poke(a.io.en,true.B)
  poke(a.io.iData,pt.U)
  poke(a.io.ed,true.B)
  step(1)
  expect(a.io.done,true.B)
  expect(a.io.result,ept.U)
  
    
  val pt2 ="h65d46a062e6ba4e99ada5e5c0b8532da"
 
  poke(a.io.key,key.U)
  poke(a.io.en,true.B)
  poke(a.io.iData,pt2.U)
  poke(a.io.ed,true.B)
  step(1)
  expect(a.io.done,true.B)
  println("res = %d\n".format(peek(a.io.result)))
  
  
  val pt3 ="h6934ec972f7401eb04113578b9debdd5"
 
  poke(a.io.key,key.U)
  poke(a.io.en,true.B)
  poke(a.io.iData,pt3.U)
  poke(a.io.ed,true.B)
  step(1)
  expect(a.io.done,true.B)
  println("res3 = %x\n".format(peek(a.io.result)))
  
  //expect(a.io.result,pt.U)
  
  
  //decryption test, round keys already generated by the encription process
  poke(a.io.key,key.U)
  poke(a.io.en,true.B)
  poke(a.io.iData,ept.U)
  poke(a.io.ed,false.B)
  step(1)
  expect(a.io.done,true.B)
  expect(a.io.result,pt.U)
  
  

  
  
  //key change logic test
  val nres = "h2C936BA3DDFFDDF452D4E407570A5388"
  val nk= "h5468617470206d79204b756e67204675"
  
  poke(a.io.key,nk.U)
  poke(a.io.en,true.B)
  poke(a.io.iData,ept.U)
  poke(a.io.ed,false.B)
  step(1)
  expect(a.io.done,true.B)
  expect(a.io.result,nres.U)
  
  
  
}

class fullUAesTester extends ChiselFlatSpec{
  behavior of "Aes"
  backends foreach{ backend =>
    it should s"encript the input data" in {
      Driver(()=>new uaes,backend)(a=> new fullUAesTestes(a)) should be (true)
    } 
    
  }
}